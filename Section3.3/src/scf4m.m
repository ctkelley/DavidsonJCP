function [mol,H,X,info] = scf4m(mol,options,int_cord)
% SCF4M Self Consistent Field iteration for metal.
%    [mol,H,X,info] = SCF4M(mol,options) adopts Self Consistent Field (SCF)
%    iteration to find the ground state minimum total energy and the
%    corresponding wave functions. mol is a Molecule object and options is
%    the options for running the SCF. Please read setksopt for detailed
%    information about options. SCF returns the molecule mol with/without
%    force, the Hamiltonian H, the wave functions X, and the information
%    for each iteration in info. If a crystal object is input instead of
%    molecule, the results will be generated by scf4c.
%
%   See also scf, scf4c, dcm.

%  Copyright (c) 2016-2017 Yingzhou Li and Chao Yang,
%                          Stanford University and Lawrence Berkeley
%                          National Laboratory
%  This file is distributed under the terms of the MIT License.

if (nargin < 2)
    options = setksopt();
end
if ~exist('int_cord')
    int_cord=false;
end

% Set timer
tstart  = cputime;

% Initialize input variables
verbose    = ~strcmpi(options.verbose,'off');
force      = options.force;
maxscfiter = options.maxscfiter;
scftol     = options.scftol;
what2mix   = options.what2mix;
mixtype    = options.mixtype;
mixdim     = options.mixdim;
betamix    = options.betamix;
brank      = options.brank;
X          = options.X0;
rho        = options.rho0;

nspin      = mol.nspin;
temperature= mol.temperature;
Tbeta      = temperature*8.6173324e-5/13.6;

% Initialize Hamiltonian, Wavefun, and Preconditioners
[mol,H,X,Hprec,nocc] = iterinit(mol,rho,X);

% calculate Ewald and Ealphat
Eewald     = getEewald(mol);
Ealphat    = getEalphat(mol);

vion       = H.vion;
vext       = H.vext;
vtot       = H.vtot;
rho        = H.rho;

% Initialize output variables
Etotvec    = zeros(maxscfiter,1);
scferr     = zeros(maxscfiter,1);
dfmat      = [];
dvmat      = [];
cdfmat     = [];

info.converge = false;      % Jit
fprintf('Starting SCF4M calculation for %s...\n',mol.name);
for iterscf = 1:maxscfiter
    if mod(iterscf,10)==0
        fprintf('SCF iter %3d:\n', iterscf);
    end
    rhoin  = rho;
    vtotin = vtot;
    
    [X,ev] = updateX(mol, H, X, Hprec, options);
    
    [occ,~] = getocc(ev,nocc,Tbeta);
    
    % Update density function rho
    rho = getcharge(mol,X,occ);
    H.rho = rho;
    if strcmpi(what2mix,'rho')
        rhoerr = norm(rho(:)-rhoin(:))/norm(rhoin(:));
        scferr(iterscf) = rhoerr;
        if mod(iterscf,10)==0
            fprintf('Rel Rho Err     = %20.3e\n',rhoerr);
        end
        [rho,dfmat,dvmat,cdfmat] = potmixing(mol,rhoin,rho,...
            iterscf,mixtype, betamix, ...
            dfmat, dvmat, cdfmat, mixdim, ...
            brank);
    end
    
    Entropy = getEntropy(occ,Tbeta);
    
    % Kinetic energy and some additional energy terms
    Ekin = (2/nspin)*sum(ev.*occ);
    
    % ionic and external potential energy was included in Ekin
    % along with incorrect Ecoul and Exc. Need to correct them
    % later;
    Ecor = getEcor(mol, rho, vtot, vion, vext);
    
    % Compute Hartree and exchange correlation energy and potential
    % using the new charge density; update the total potential
    [vhart,vxc,uxc2,rho]=getVhxc(mol,rho);
    
    % Update total potential
    vtot = getVtot(mol, vion, vext, vhart, vxc);
    if strcmpi(what2mix,'pot')
        vtoterr = norm(vtot(:)-vtotin(:))/norm(vtotin(:));
        scferr(iterscf) = vtoterr;
        fprintf('Rel Vtot Err    = %20.3e\n',vtoterr);
        [vtot,dfmat,dvmat,cdfmat] = ...
            potmixing(mol,vtotin,vtot,iterscf,mixtype,...
            betamix,dfmat,dvmat,cdfmat,mixdim,brank);
    end
    H.vtot = vtot;
    
    % Calculate the potential energy based on the new potential
    Ecoul = getEcoul(mol,abs(rho),vhart);
    Exc   = getExc(mol,abs(rho),uxc2);
    Etot  = Entropy + Ekin + Eewald + Ealphat + Ecor + Ecoul + Exc;
    Etotvec(iterscf) = Etot;
    
    % Convergence check
    fprintf('Total Energy    = %20.13e\n', Etot);
    [cvg,resfro] = reportconverge(H,X,iterscf,maxscfiter, ...
        scferr(iterscf),scftol,verbose);
    if cvg
        info.converge = true;
        break;
    end
    
end

X.occ = occ;
if force
    mol.xyzforce = getFtot(mol,H,X,rho,int_cord);
end

info.Eigvals = ev;
info.Etotvec = Etotvec(1:iterscf);
info.SCFerrvec = scferr(1:iterscf);

info.Etot = Etot;                                % Jit
info.eentropy = Entropy;                         % Jit
info.Efree = Etotvec(end) - Tbeta*Entropy;       % Jit

timetot = cputime - tstart;
fprintf('Etot            = %20.13e\n', Etot);
fprintf('Entropy         = %20.13e\n', Entropy);
fprintf('Ekin            = %20.13e\n', Ekin);
fprintf('Eewald          = %20.13e\n', Eewald);
fprintf('Ealphat         = %20.13e\n', Ealphat);
fprintf('Ecor            = %20.13e\n', Ecor);
fprintf('Ecoul           = %20.13e\n', Ecoul);
fprintf('Exc             = %20.13e\n', Exc);
fprintf('--------------------------------------\n');
fprintf('Total time used = %20.3e\n', timetot);
fprintf('||HX-XD||_F     = %20.3e\n', resfro);

end
